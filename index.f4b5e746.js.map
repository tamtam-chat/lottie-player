{"version":3,"file":"index.f4b5e746.js","sources":["../vite/modulepreload-polyfill","../src/lib/Player.ts","../src/lib/utils.ts","../src/lib/config.ts","../src/lib/worker-pool.ts","../src/main.ts","../src/assets/heart.json?url","../src/playground.ts"],"sourcesContent":["__VITE_IS_MODERN__&&(function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n}());","import type { CreateResponse, ID, PlayerOptions } from '../types';\n\nlet globalId = 0;\n\nexport interface PlayerEventMap {\n    mount: [totalFrames: number, frameRate: number];\n    play: [];\n    pause: [];\n    end: [];\n    rendered: [];\n    resize: [width: number, height: number, dpr: number];\n    dispose: [];\n}\n\ntype PlayerEventNames = keyof PlayerEventMap;\ntype Listener = (...args: any[]) => void;\n\nexport default class Player {\n    public readonly id: ID;\n    public canvas: HTMLCanvasElement;\n    public ctx: CanvasRenderingContext2D;\n    public loop: boolean;\n    public dpr: number;\n    public paused = false;\n    public frame = -1;\n    public totalFrames = -1;\n    public frameRate = 60;\n    public disposed = false;\n    public fill: string | undefined;\n\n    private listeners: { [K in PlayerEventNames]?: Listener[] } = {};\n\n    constructor(options: PlayerOptions) {\n        const { canvas } = options;\n        const width = options.width || canvas.width;\n        const height = options.height || canvas.height;\n\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: true })!;\n        this.id = options.id || `__lottie${globalId++}`;\n        this.dpr = options.dpr || window.devicePixelRatio || 1;\n        this.loop = options.loop || false;\n        if (options.fps) {\n            this.frameRate = options.fps;\n        }\n\n        if (options.fill) {\n            this.fill = options.fill;\n        }\n\n        this.resize(width, height);\n    }\n\n    get width() {\n        return this.canvas?.width || 0;\n    }\n\n    get height() {\n        return this.canvas?.height || 0;\n    }\n\n    get mounted() {\n        return this.totalFrames !== -1;\n    }\n\n    get frameTime() {\n        return 1000 / this.frameRate;\n    }\n\n    get lastFrame() {\n        return this.totalFrames - 1;\n    }\n\n    /**\n     * Запускает воспроизведение анимации\n     */\n    play() {\n        let shouldPlay = false;\n\n        if (this.paused) {\n            this.paused = false;\n            shouldPlay = true;\n        }\n\n        if (this.loop && this.frame === this.lastFrame) {\n            this.frame = 0;\n            shouldPlay = true;\n        }\n\n        if (shouldPlay) {\n            this.emit('play');\n        }\n    }\n\n    /**\n     * Останавливает воспроизведение анимации\n     */\n    pause() {\n        if (!this.paused) {\n            this.paused = true;\n            this.emit('pause');\n        }\n    }\n\n    /**\n     * Переключает воспроизведение анимации\n     */\n    toggle() {\n        if (this.paused) {\n            this.play();\n        } else {\n            this.pause()\n        }\n    }\n\n    /**\n     * Меняет размер холста с анимацией. Так же убедится, что размер отрисовываемого\n     * кадра будет не меньше\n     */\n    resize(width: number, height: number, dpr = this.dpr) {\n        const { canvas } = this;\n        if (canvas) {\n            this.dpr = dpr;\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            canvas.style.width = `${width}px`;\n            canvas.style.height = `${height}px`;\n\n            if (this.mounted) {\n                this.emit('resize', width, height, dpr);\n            }\n        }\n    }\n\n    /**\n     * Вызывается в момент, когда для указанного плеера смонтировался воркер.\n     */\n    mount(data: CreateResponse) {\n        if (!this.mounted) {\n            this.totalFrames = data.totalFrames;\n            this.frameRate = data.frameRate || 60;\n            this.emit('mount', this.totalFrames, data.frameRate);\n        }\n    }\n\n    /**\n     * Удаляет текущий экземпляр плеера\n     */\n    dispose() {\n        this.disposed = true;\n        this.frame = this.totalFrames = -1;\n        this.emit('dispose');\n        this.listeners = {};\n    }\n\n    /**\n     * Подписка на событие\n     */\n    on<E extends PlayerEventNames>(event: E, callback: (...args: PlayerEventMap[E]) => void): this {\n        const listeners = this.listeners[event];\n        if (listeners) {\n            if (!listeners.includes(callback as Listener)) {\n                listeners.push(callback as Listener);\n            }\n        } else {\n            this.listeners[event] = [callback as Listener];\n        }\n        return this;\n    }\n\n    /**\n     * Отписка от события\n     */\n    off<E extends PlayerEventNames>(event: E, callback: (...args: PlayerEventMap[E]) => void): this {\n        const listeners = this.listeners[event];\n        if (listeners) {\n            // NB: используем новый массив, так как отписка от событий во время\n            // выброса события приведет к потере вызова коллбэков\n            const nextListeners: Listener[] = [];\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i] !== callback) {\n                    nextListeners.push(listeners[i]);\n                }\n            }\n            this.listeners[event] = nextListeners;\n        }\n\n        return this;\n    }\n\n    emit<E extends PlayerEventNames>(event: E, ...args: PlayerEventMap[E]): this {\n        const listeners = this.listeners[event];\n        if (listeners) {\n            for (let i = 0; i < listeners.length; i++) {\n                listeners[i].apply(this, args);\n            }\n        }\n        return this;\n    }\n}\n","export interface Deferred<T> {\n    promise: Promise<T>;\n    resolve: (value: T) => void;\n    reject: (err?: Error) => void;\n}\n\nexport function deferred<T>(): Deferred<T> {\n    let resolve: (value: T) => void = () => { /* empty */ };\n    let reject: (err?: Error) => void = () => { /* empty */ };\n    const promise = new Promise<T>((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n    });\n\n    return { promise, resolve, reject };\n}\n\n/**\n * Возвращает содержимое Lottie-анимации для передачи в воркер\n */\nexport function getMovie(movie: string | object): Promise<string> {\n    // NB: не используем async/await для поддержки старых браузеров\n    return Promise.resolve().then(() => {\n        if (typeof movie === 'string') {\n            if (/^(https?|data|file):/.test(movie)) {\n                return fetch(movie, { mode: 'cors' }).then(res => {\n                    if (res.ok) {\n                        return res.text();\n                    }\n\n                    throw new Error(`Invalid response: ${res.status}: ${res.statusText}`);\n                });\n            }\n\n            return movie;\n        }\n\n        return JSON.stringify(movie);\n    });\n}\n\nexport function isSameSize(canvas: HTMLCanvasElement, frame: ImageData): boolean {\n    return frame.width === canvas.width && frame.height === canvas.height;\n}\n","import { Config } from '../types';\nimport RLottieWorker from '../worker?worker&url';\n\nconst config: Config = {\n    maxWorkers: 4,\n    playersPerWorker: 5,\n    workerUrl: RLottieWorker,\n    cacheFrames: false\n};\n\n/**\n * Обновление параметров контроллера плеера\n */\n export function updateConfig(data: Partial<Config>): void {\n    Object.assign(config, data);\n}\n\n/**\n * Возвращает текущий конфиг\n */\nexport function getConfig(): Config {\n    return config;\n}\n","import type { RequestMap, WorkerRequest, WorkerMessage } from '../types';\nimport { getConfig } from './config';\nimport { type Deferred, deferred } from './utils';\n\nexport const workerPool: WorkerInstance[] = [];\nconst maxSeq = 1_000_000;\nlet workerUrlLoader: Promise<string> | undefined;\nlet workerId = 1;\n\nexport class WorkerInstance {\n    public refs = 0;\n    public readonly id: number;\n    private deferred = deferred<WorkerInstance>();\n    private worker: Worker | undefined;\n    private seq = 0;\n    private requests = new Map<number, Deferred<any>>();\n\n    constructor() {\n        this.id = workerId++;\n    }\n\n    onMessage = (evt: MessageEvent<WorkerMessage>) => {\n        if ('seq' in evt.data) {\n            const { seq, payload } = evt.data;\n            const resp = this.requests.get(seq);\n            if (resp) {\n                this.requests.delete(seq);\n                resp.resolve(payload);\n            }\n        }\n    }\n\n    get promise(): Promise<WorkerInstance> {\n        return this.deferred.promise;\n    }\n\n    /**\n     * Шлёт запрос в указанный воркер\n     */\n    send<K extends keyof RequestMap>(name: K, payload: RequestMap[K][0]): Promise<RequestMap[K][1]> {\n        this.seq = (this.seq + 1) % maxSeq;\n        const seq = this.seq;\n        const req: WorkerRequest<K> = { name, payload, seq };\n        const resp = deferred<RequestMap[K][1]>();\n        if (this.worker) {\n            this.requests.set(seq, resp);\n            this.worker.postMessage(req);\n        } else {\n            resp.reject(new Error('Worker is not mounted'));\n        }\n\n        return resp.promise;\n    }\n\n    attach(worker: Worker) {\n        this.worker = worker;\n        this.worker.addEventListener('message', this.onMessage);\n        this.deferred.resolve(this);\n    }\n\n    fail(err?: Error) {\n        this.deferred.reject(err);\n    }\n\n    dispose() {\n        if (this.requests.size) {\n            this.requests.forEach(req => req.reject(terminateErr()));\n            this.requests.clear();\n        }\n\n        if (this.worker) {\n            this.worker.removeEventListener('message', this.onMessage);\n            this.worker.terminate();\n            this.worker = undefined;\n        } else {\n            this.fail(terminateErr());\n        }\n    }\n}\n\n/**\n * Выделяет воркер для RLottie: либо создаёт новый, либо переиспользует существующий\n */\nexport function allocWorker(): Promise<WorkerInstance> {\n    const config = getConfig();\n    let worker: WorkerInstance | undefined;\n    let minPlayersWorker: WorkerInstance | undefined;\n\n    for (let i = 0; i < workerPool.length; i++) {\n        const item = workerPool[i];\n        if (item.refs < config.playersPerWorker) {\n            worker = item;\n            break;\n        }\n\n        if (!minPlayersWorker || minPlayersWorker.refs > item.refs) {\n            minPlayersWorker = item;\n        }\n    }\n\n    // Если добрались сюда, значит, нет подходящего инстанса. Либо создадим новый,\n    // либо будем превышать лимиты на существующих\n    if (!worker && minPlayersWorker && workerPool.length >= config.maxWorkers) {\n        worker = minPlayersWorker;\n    }\n\n    if (!worker) {\n        worker = new WorkerInstance();\n        workerPool.push(worker);\n        attachWorker(worker);\n    }\n\n    worker.refs++;\n    return worker.promise;\n}\n\n/**\n * Освобождает указанный инстанс воркера\n */\n export function releaseWorker(instance: WorkerInstance) {\n    instance.refs--;\n    if (instance.refs <= 0) {\n        instance.dispose();\n\n        const itemIx = workerPool.indexOf(instance);\n        if (itemIx !== -1) {\n            workerPool.splice(itemIx, 1);\n        }\n    }\n}\n\n/**\n * Добавляет воркер к указанному инстансу\n */\n function attachWorker(instance: WorkerInstance) {\n    getWorkerUrl().then(url => {\n        const worker = new Worker(url, { type: 'module' });\n\n        const cleanUp = () => {\n            worker.removeEventListener('message', onMessage);\n            worker.removeEventListener('error', onError);\n        };\n\n        const onMessage = (evt: MessageEvent<{ type?: string }>) => {\n            if (evt.data.type === 'init') {\n                cleanUp();\n\n                if (workerPool.includes(instance)) {\n                    instance.attach(worker);\n                } else {\n                    // Инстанс больше не нужен\n                    worker.terminate();\n                    instance.fail(terminateErr());\n                }\n            }\n        };\n\n        const onError = (evt: ErrorEvent) => {\n            cleanUp();\n            instance.fail(new Error(evt.error || evt.message));\n        };\n\n        worker.addEventListener('message', onMessage);\n        worker.addEventListener('error', onError);\n    });\n}\n\n/**\n * Возвращает промис со ссылкой на воркер\n */\n function getWorkerUrl(): Promise<string> {\n    if (!workerUrlLoader) {\n        const entry = getConfig().workerUrl;\n        let workerUrl: string | Promise<string> = typeof entry === 'function' ? entry() : entry;\n        if (typeof workerUrl === 'string') {\n            workerUrlLoader = Promise.resolve(workerUrl);\n        } else {\n            workerUrlLoader = workerUrl;\n        }\n    }\n\n    return workerUrlLoader;\n}\n\nfunction terminateErr() {\n    return new Error('ETERMINATE');\n}\n","import Player from './lib/Player';\nimport { getMovie } from './lib/utils';\nimport { allocWorker, releaseWorker, workerPool, type WorkerInstance } from './lib/worker-pool';\nimport { FrameRequest, FrameResponse, ID, PlayerOptions, RenderResponse, Config, RenderStats } from './types';\nimport { getConfig } from './lib/config';\n\nexport { updateConfig, getConfig } from './lib/config';\nexport type { Player };\nexport type { PlayerOptions, Config, ID };\n\ninterface PlayerRegistryItem {\n    id: ID;\n\n    /** Зарегистрированные плееры */\n    players: Player[];\n\n    /** Последний отрисованный кадр */\n    frame: number;\n\n    /** FPS текущей анимации */\n    frameRate: number;\n\n    /** Всего кадров в анимации */\n    totalFrames: number;\n\n    /** Время начала воспроизведения */\n    start: number;\n\n    /** Кэш отрисованных кадров */\n    frameCache?: ImageData[];\n\n    /** Инстанс воркера-отрисовщика, закреплённого за текущим элементом */\n    worker?: WorkerInstance;\n}\n\n/** Реестр всех зарегистрированных плееров и привязанным к ним воркерам */\nconst registry = new Map<ID, PlayerRegistryItem>();\n\n/** Глобальный флаг для остановки всех плееров */\nlet paused = false;\nlet rafId: number = 0;\n\n/**\n * Время предыдущей отрисовки кадра. Используется для получения дельты для кадра,\n * который нужно нарисовать\n */\nlet prevTime = 0;\n\n/**\n * Количество плееров, которые можно отрисовать. -1 означает, что рисуем всё,\n * 0 — нарисуем только один кадр, > 0 — можно обновить текущий плеер\n */\nlet maxPlayerRender = -1;\n\n/**\n * Флаг, указывающий, доступна ли поддержка RLottie в текущей среде\n */\nexport const isSupported = wasmIsSupported() &&\n    typeof Uint8ClampedArray !== 'undefined' &&\n    typeof Worker !== 'undefined' &&\n    typeof ImageData !== 'undefined';\n\n/**\n* Проверка поддержки работы WASM\n*/\nfunction wasmIsSupported() {\n    try {\n        if (typeof WebAssembly === 'object' &&\n            typeof WebAssembly.instantiate === 'function') {\n            const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));\n\n            if (module instanceof WebAssembly.Module) {\n                return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\n            }\n        }\n    } catch (e) { }\n    return false;\n}\n\n/**\n * Буфферный canvas, через который будем рисовать кадры другого размера\n */\n const bufCanvas = document.createElement('canvas');\n\n/**\n * Создаёт плеер для указанной анимации\n */\nexport function createPlayer(options: PlayerOptions): Player {\n    const player = new Player(options);\n    registerPlayer(player, options.movie);\n\n    player\n        .on('play', () => scheduleRender())\n        .on('dispose', () => unregisterPlayer(player))\n        .on('resize', () => orderInstances(player.id));\n    return player;\n}\n\n/**\n * Универсальный механизм для удаления плеера: можно передать сам плеер или\n * `<canvas>`, в котором рисуется анимация. Если указать `id` анимации, то будут\n * удалены все плееры с этим идентификатором.\n */\nexport function disposePlayer(player: ID | HTMLCanvasElement | Player) {\n    if (player instanceof Player) {\n        player.dispose();\n    } else if (player && typeof player === 'object' && 'nodeType' in player) {\n        // Удаляем плеер для указанного канваса\n        registry.forEach(item => {\n            item.players.forEach(item => {\n                if (item.canvas === player) {\n                    item.dispose();\n                }\n            });\n        });\n    } else {\n        const item = registry.get(player);\n        item?.players.forEach(item => item.dispose());\n    }\n}\n\n/**\n * Запуск воспроизведения всех зарегистрированных плееров\n */\nexport function play() {\n    paused = false;\n    scheduleRender();\n}\n\n/**\n * Остановка воспроизведения всех зарегистрированных плееров\n */\nexport function pause() {\n    paused = true;\n    cancelAnimationFrame(rafId);\n    rafId = prevTime = 0;\n}\n\n/**\n * Возвращает внутренности плеера для отладки\n * @private\n */\nexport function getInternals() {\n    return { registry, workerPool, paused, rafId };\n}\n\n/**\n * Регистрирует указанный плеер в реестре плееров\n */\nfunction registerPlayer(player: Player, movie: PlayerOptions['movie']) {\n    const { id } = player;\n    const item = registry.get(id);\n    if (item) {\n        // Уже есть запись реестра для плеера: значит, воспроизводим группу\n        item.players.push(player);\n        orderInstances(id);\n        if (item.worker) {\n            player.mount(item);\n            scheduleRender();\n        }\n    } else {\n        const item: PlayerRegistryItem = {\n            id,\n            frame: 0,\n            totalFrames: -1,\n            frameRate: 60,\n            start: 0,\n            players: [player]\n        };\n        registry.set(id, item);\n\n        // Параллельно загружаем воркер и ролик.\n        // Не используем async/await для поддержки старых браузеров и для\n        // сокращения кода при транспиляции\n        Promise.all([allocWorker(), getMovie(movie)]).then(([worker, data]) => {\n            // Создаём плеер для ролика\n            worker.send('create', { id, data }).then(resp => {\n                // Убедимся, что запись всё ещё присутствует и актуальна\n                if (registry.get(id) === item) {\n                    item.worker = worker;\n                    item.totalFrames = resp.totalFrames;\n                    if (resp.frameRate) {\n                        item.frameRate = resp.frameRate;\n                    }\n                    item.players.forEach(player => player.mount(resp));\n                    scheduleRender();\n                } else {\n                    releaseWorker(worker);\n                }\n            });\n        });\n    }\n}\n\n/**\n * Удаляет указанный плеер из реестра плееров\n */\nfunction unregisterPlayer(player: Player) {\n    const { id } = player;\n    const item = registry.get(id);\n    if (item) {\n        item.players = item.players.filter(p => p !== player);\n        if (!item.players.length) {\n            registry.delete(id);\n\n            if (item.worker) {\n                releaseWorker(item.worker);\n            }\n        }\n    }\n}\n\n/**\n * Сортируем список по размеру, от большего к меньшему.\n * Решаем две задачи: находим мастер-плеер (под размер которого рисует RLottie)\n * и группируем плееры по размеру. В этом случае из можно отрисовывать по\n * очереди и отдавать предыдущий плеер как референс: тем самым мы минимизируем\n * количество масштабирований при отрисовке плееров с разным размером\n */\nfunction orderInstances(id: ID) {\n    const item = registry.get(id);\n    if (item && item.players.length > 1) {\n        item.players.sort((a, b) => b.width - a.width);\n    }\n}\n\n/**\n * Вернёт `true`, если указанный плеер можно воспроизводить\n */\nfunction isPlaying(player: Player): boolean {\n    return player.paused\n        ? false\n        : player.loop || (player.frame < player.totalFrames - 1);\n}\n\n/**\n * Планирует цикл отрисовки на следующий кадр, если это необходимо\n */\nfunction scheduleRender() {\n    if (!rafId && !paused) {\n        rafId = requestAnimationFrame(render);\n    }\n}\n\n/**\n * Цикл отрисовки: рисует следующий кадр для всех зарегистрированных плееров\n */\nfunction render(time: number) {\n    let rendered = false;\n    maxPlayerRender = getConfig().maxRender || -1;\n    const tickDelta = prevTime ? time - prevTime : 0;\n    const stats: RenderStats = {\n        frameTime: 0,\n        paintTime: 0,\n        tickDelta\n    };\n\n    /** Запросы на отрисовку, распределённые между своими воркерами */\n    const workerPayload = new Map<WorkerInstance, FrameRequest[]>();\n\n    // Сформируем нагрузку для отрисовки\n    registry.forEach(item => {\n        const { worker, players } = item;\n        const firstPlaying = worker && players.find(isPlaying);\n        if (firstPlaying) {\n            // Есть плееры, где надо отрисовать кадры\n            rendered = true;\n            if (!item.start) {\n                // Записываем время начала воспроизведения минус\n                // смещение, чтобы начать отрисовывать с указанного кадра\n                item.start = time - ((item.frame % firstPlaying.lastFrame) * firstPlaying.frameTime);\n            }\n\n            const req = toFrameRequest(firstPlaying, time - item.start);\n            const cachedFrame = getCachedFrame(req);\n            if (cachedFrame) {\n                stats.paintTime += renderGroup(req.id, req.frame, cachedFrame);\n            } else if (shouldRenderFrame(req.id, req.frame)) {\n                const queue = workerPayload.get(worker);\n                if (queue) {\n                    queue.push(req);\n                } else {\n                    workerPayload.set(worker, [req]);\n                }\n            }\n            item.frame = req.frame;\n        } else {\n            // Нет активных плееров: сбрасываем время начала воспроизведения\n            item.start = 0;\n        }\n    });\n\n    prevTime = time;\n\n\n    if (workerPayload.size) {\n        // Есть данные, которые нужно нарисовать через воркеры\n        const start = performance.now();\n        const promises: Promise<RenderResponse>[] = [];\n        workerPayload.forEach((frames, worker) => {\n            const req = worker.send('render', { frames })\n                // Возможна ситуация, когда воркер уже размонтировался\n                // в процессе отрисовки кадра, то есть плееры уже не нужны,\n                // но воркер ещё не успел ответить. В этом случае контроллер сфэйлит все\n                // зависшие запросы в воркере, но мы не должны прерываться\n                .catch(() => ({ frames: [] }));\n            promises.push(req);\n        });\n\n        Promise.all(promises).then(resp => {\n            stats.frameTime = performance.now() - start;\n            resp.forEach(payload => {\n                payload.frames.forEach(frame => {\n                    stats.paintTime += renderFrameResponse(frame);\n                });\n            });\n            reportStats(stats);\n            restartLoop();\n        })\n        .catch(() => restartLoop());\n    } else {\n        // Данных для воркера нет либо отрисовали из кэша\n        reportStats(stats);\n        restartLoop(rendered);\n    }\n}\n\n/**\n * Вернёт закэшированный кадр, если его можно отрисовать для указанного запроса\n */\nfunction getCachedFrame(req: FrameRequest): ImageData | void {\n    const item = registry.get(req.id);\n    if (item?.frameCache) {\n        const frame = item.frameCache[req.frame];\n        if (frame && frame.width >= req.width && frame.height >= req.height) {\n            return frame;\n        }\n    }\n}\n\n/**\n * Записывает отрисованный кадр в кэш\n */\nfunction setCachedFrame(id: ID, frame: number, image: ImageData) {\n    const item = registry.get(id);\n    if (item && item.totalFrames !== -1) {\n        if (!item.frameCache) {\n            item.frameCache = new Array(item.totalFrames);\n        }\n\n        item.frameCache[frame] = image;\n    }\n}\n\nfunction toFrameRequest(player: Player, elapsed: number): FrameRequest {\n    // В аругументе elapsed указано, сколько времени прошло с начала воспроизведения\n    // плеера — посчитаем из него кадр\n    let frame = Math.floor(elapsed / player.frameTime);\n    frame = player.loop ? frame % player.lastFrame : Math.min(frame, player.lastFrame);\n\n    return {\n        id: player.id,\n        width: player.width,\n        height: player.height,\n        frame\n    };\n}\n\nfunction restartLoop(rendered?: boolean) {\n    rafId = 0;\n    if (rendered !== false) {\n        scheduleRender();\n    } else {\n        prevTime = 0;\n    }\n}\n\n/**\n * Отрисовка кадра из ответа от воркера.\n * Вернёт время, затраченное на отрисовку\n */\nfunction renderFrameResponse(payload: FrameResponse): number {\n    const start = performance.now();\n    const { id } = payload;\n    if (registry.has(id)) {\n        const clampedBuffer = new Uint8ClampedArray(payload.data);\n        const image = new ImageData(clampedBuffer, payload.width, payload.height);\n\n        if (getConfig().cacheFrames) {\n            setCachedFrame(id, payload.frame, image);\n        }\n\n        renderGroup(id, payload.frame, image);\n    }\n\n    return performance.now() - start;\n}\n\n/**\n * Отрисовка кадра для указанной группы. Вернёт время, затраченное на отрисовку\n */\nfunction renderGroup(id: ID, frame: number, image: ImageData): number {\n    const start = performance.now();\n    const item = registry.get(id);\n    let prevRendered: HTMLCanvasElement | undefined;\n\n    if (item) {\n        const { players } = item;\n        // const lastPlayer = players.length - 1;\n        for (let i = 0; i < players.length; i++) {\n            const player = players[i];\n            if (isPlaying(player) && shouldRenderPlayer(player, frame)) {\n                renderFrame(player, frame, image, prevRendered);\n                prevRendered = player.canvas;\n\n                // const { width, height } = player;\n                // if (i !== lastPlayer && (image.width !== width || image.height !== height)) {\n                //     image = player.ctx.getImageData(0, 0, width, height);\n                // }\n            }\n        }\n    }\n\n    return performance.now() - start;\n}\n\n/**\n * Отрисовка кадра в указанном плеере\n */\nfunction renderFrame(player: Player, frame: number, image: ImageData, prev?: HTMLCanvasElement) {\n    const isInitial = player.frame === -1;\n    const { ctx, canvas, fill } = player;\n    const { width, height } = canvas;\n    const shouldRender = maxPlayerRender === -1 || maxPlayerRender > 0 || isInitial;\n\n    if (shouldRender) {\n        if (image.width === width && image.height === height && !fill) {\n            // putImage — самый быстрый вариант, будем использовать его, если размер подходит\n            ctx.putImageData(image, 0, 0);\n        } else {\n            if (!prev) {\n                // Нет предыдущего отрисованный canvas, который можно отмасштабировать\n                // до нужного размера: используем буфферный\n                bufCanvas.width = image.width\n                bufCanvas.height = image.height;\n                const bufCtx = bufCanvas.getContext('2d')!;\n                bufCtx.putImageData(image, 0, 0);\n                prev = bufCanvas;\n            }\n\n            if (fill) {\n                ctx.save();\n                ctx.fillStyle = fill;\n                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n                ctx.globalCompositeOperation = 'destination-in';\n                ctx.drawImage(prev, 0, 0, width, height);\n                ctx.restore();\n            } else {\n                ctx.clearRect(0, 0, width, height);\n                ctx.drawImage(prev, 0, 0, width, height);\n            }\n        }\n\n        if (maxPlayerRender > 0) {\n            maxPlayerRender--;\n        }\n    }\n\n    player.frame = frame;\n    if (isInitial) {\n        player.emit('rendered');\n    }\n\n    if (isFinished(player)) {\n        player.pause();\n        player.emit('end');\n    }\n}\n\n/**\n * Вернёт `true`, если в указанной группе необходимо отрисовать указанный кадр.\n * В частности проверяет, был этот кадр уже отрисован\n */\nfunction shouldRenderFrame(id: ID, frame: number): boolean {\n    const item = registry.get(id);\n    if (item) {\n        return item.players.some(p => shouldRenderPlayer(p, frame));\n    }\n\n    return false;\n}\n\n/**\n * Вернёт `true` если указанный кадр нужно нарисорвать в плеере\n */\nfunction shouldRenderPlayer(player: Player, frame: number): boolean {\n    return player.totalFrames !== -1 && player.frame !== frame;\n}\n\nfunction reportStats(data: RenderStats) {\n    const { stats } = getConfig();\n    if (stats) {\n        stats(data);\n    }\n}\n\nfunction isFinished(player: Player) {\n    return !player.loop && player.frame === player.lastFrame;\n}\n","export default \"__VITE_ASSET__c47dc43a__\"","import { createPlayer, updateConfig, getInternals, Player } from './main';\nimport { RenderStats } from './types';\nimport acrobatics from './assets/acrobatics.json?inline';\nimport emojiWink from './assets/emoji_wink.json?inline';\nimport heart from './assets/heart.json?url';\nimport loader from './assets/gradient_sleepy_loader.json?inline';\nimport textTyping from './assets/text.json?inline';\n\nconst fireMovie = 'https://st.mycdn.me/static/messages/2022-11-30lottie/e/10.json';\n\nconst app = document.getElementById('app')!\nconst controls = document.getElementById('controls')!;\nconst statsElem = document.getElementById('stats')!;\nconst statsItems: RenderStats[] = [];\n\nlet width = 100;\nlet height = 100;\n\ninterface MovieOptions {\n    id?: string;\n    movie: string | object;\n    width: number;\n    height: number;\n    loop?: boolean;\n    fill?: string;\n}\n\nfunction createMovie(opt: MovieOptions) {\n    const canvas = document.createElement('canvas');\n    canvas.width = opt.width;\n    canvas.height = opt.height;\n\n    app.appendChild(canvas);\n\n    const player = createPlayer({\n        ...opt,\n        canvas,\n        movie: typeof opt.movie === 'string'\n            ? opt.movie : JSON.stringify(opt.movie),\n    });\n\n    canvas.addEventListener('click', evt => {\n        if (evt.altKey) {\n            player.toggle();\n            console.log('toggle playback');\n        } else {\n            canvas.remove();\n            player.dispose();\n            console.log('disposed player');\n        }\n    });\n\n    return player;\n}\n\nfunction createFire(amount: number) {\n    const fire = document.createElement('div');\n    fire.className = 'fire';\n    const players: Player[] = [];\n    let first = true;\n    while (amount--) {\n        const canvas = document.createElement('canvas');\n        fire.appendChild(canvas);\n\n        const player = createPlayer({\n            width: first ? 50 : 20,\n            height: first ? 50 : 20,\n            id: 'fire',\n            loop: true,\n            canvas,\n            movie: fireMovie,\n        });\n        players.push(player);\n        first = false;\n    }\n\n    fire.addEventListener('click', () => {\n        players.forEach(p => p.dispose());\n        players.length = 0;\n        fire.remove();\n    });\n\n    app.appendChild(fire);\n}\n\nfunction createButton(label: string, onClick?: (evt: MouseEvent) => void) {\n    const btn = document.createElement('button');\n    btn.innerText = label;\n    if (onClick) {\n        btn.addEventListener('click', onClick);\n    }\n    controls.append(btn);\n    return btn;\n}\n\nfunction createControls() {\n    createButton('Acrobatics', () => {\n        createMovie({\n            id: 'acrobatics',\n            movie: acrobatics,\n            loop: true,\n            width,\n            height\n        });\n        width += 20;\n        height += 20;\n    });\n\n    // XXX загрузка внешних картинок пока не поддерживается\n    // createButton('External image', () => {\n    //     createMovie({\n    //         movie: createExternalAnimation('https://st.mycdn.me/static/emoji/14-0-0/32/1f648@2x.png'),\n    //         loop: true,\n    //         width: 100,\n    //         height: 100\n    //     });\n    // });\n\n    createButton('Emoji wink', createMovieHandler(emojiWink));\n    createButton('Heart', createMovieHandler(new URL(heart, location.href).href));\n    createButton('Loader', createMovieHandler(loader, 'gradient'));\n    createButton('Typing', () => {\n        createMovie({\n            id: 'typing',\n            movie: textTyping,\n            loop: true,\n            width: 100,\n            height: 100,\n            fill: '#ccc'\n        });\n    });\n    createButton('Fire', () => createFire(400));\n\n    createButton('Log internals', () => console.log(getInternals()));\n}\n\nfunction createMovieHandler(movie: string | object, id?: string) {\n    return () => createMovie({\n        id,\n        movie,\n        loop: true,\n        width: 100,\n        height: 100\n    });\n}\n\n// Для отладки сокращаем лимиты\nupdateConfig({\n    maxWorkers: 3,\n    playersPerWorker: 2,\n    cacheFrames: true,\n    maxRender: 100,\n    stats(data) {\n        statsItems.push(data);\n        while (statsItems.length > 50) {\n            statsItems.shift();\n        }\n\n        let frameTime = 0;\n        let paintTime = 0;\n        let tickDelta = 0;\n\n        const avg = (value: number) => (value / statsItems.length).toFixed(2);\n\n        statsItems.forEach(item => {\n            frameTime += item.frameTime;\n            paintTime += item.paintTime;\n            tickDelta += item.tickDelta;\n        });\n\n        statsElem.innerHTML = `Frame time: ${avg(frameTime)}ms\\nPaint time: ${avg(paintTime)}ms\\nTick: ${avg(tickDelta)}ms`;\n    }\n});\n\nfunction setupFilePicker() {\n    const picker = document.getElementById('lottie-picker') as HTMLInputElement;\n    if (picker) {\n        picker.addEventListener('change', async () => {\n            const file = picker.files?.[0];\n            if (file) {\n                const movie = await file.text();\n                const movieData = JSON.parse(movie)\n\n                createMovie({\n                    width: movieData.w || 400,\n                    height: movieData.h || 400,\n                    movie,\n                    loop: true\n                });\n                picker.value = '';\n            }\n        });\n    }\n}\n\ncreateControls();\nsetupFilePicker();\n"],"names":["relList","link","processPreload","mutations","mutation","node","getFetchOpts","script","fetchOpts","globalId","Player","options","__publicField","canvas","width","height","_a","shouldPlay","dpr","data","event","callback","listeners","nextListeners","i","args","deferred","resolve","reject","_resolve","_reject","getMovie","movie","res","config","RLottieWorker","updateConfig","getConfig","workerPool","maxSeq","workerUrlLoader","workerId","WorkerInstance","evt","seq","payload","resp","name","req","worker","err","terminateErr","allocWorker","minPlayersWorker","item","attachWorker","releaseWorker","instance","itemIx","getWorkerUrl","url","cleanUp","onMessage","onError","entry","workerUrl","registry","paused","rafId","prevTime","maxPlayerRender","wasmIsSupported","module","e","bufCanvas","createPlayer","player","registerPlayer","scheduleRender","unregisterPlayer","orderInstances","getInternals","id","p","a","b","isPlaying","render","time","rendered","stats","workerPayload","players","firstPlaying","toFrameRequest","cachedFrame","getCachedFrame","renderGroup","shouldRenderFrame","queue","start","promises","frames","frame","renderFrameResponse","reportStats","restartLoop","setCachedFrame","image","elapsed","clampedBuffer","prevRendered","shouldRenderPlayer","renderFrame","prev","isInitial","ctx","fill","isFinished","heart","fireMovie","app","controls","statsElem","statsItems","createMovie","opt","createFire","amount","fire","first","createButton","label","onClick","btn","createControls","acrobatics","createMovieHandler","emojiWink","loader","textTyping","frameTime","paintTime","tickDelta","avg","value","setupFilePicker","picker","file","movieData"],"mappings":"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"}